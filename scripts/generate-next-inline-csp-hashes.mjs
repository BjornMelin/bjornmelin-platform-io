import crypto from "node:crypto";
import fs from "node:fs";
import path from "node:path";

function readArg(flag) {
  const idx = process.argv.indexOf(flag);
  if (idx === -1) return null;
  const value = process.argv[idx + 1];
  if (!value || value.startsWith("--")) return null;
  return value;
}

function* walkHtmlFiles(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) yield* walkHtmlFiles(fullPath);
    else if (entry.isFile() && fullPath.endsWith(".html")) yield fullPath;
  }
}

function computeInlineScriptHashes(html) {
  const hashes = new Set();
  const scriptRe = /<script\b([^>]*)>([\s\S]*?)<\/script\s*>/gi;

  let match;
  while ((match = scriptRe.exec(html))) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";

    // External scripts are covered by `'self'` and don't need hashes.
    if (/\bsrc\s*=/i.test(attrs)) continue;

    // Ignore JSON-LD blocks.
    const type = (attrs.match(/\btype\s*=\s*"([^"]+)"/i)?.[1] ?? "").toLowerCase();
    if (type === "application/ld+json") continue;

    // Ignore empty scripts.
    if (!body.trim()) continue;

    const digest = crypto.createHash("sha256").update(body, "utf8").digest("base64");
    hashes.add(`sha256-${digest}`);
  }

  return hashes;
}

const outDir = path.resolve(readArg("--out-dir") ?? "out");
const target = path.resolve(
  readArg("--target") ?? "infrastructure/lib/generated/next-inline-script-hashes.ts",
);

if (!fs.existsSync(outDir)) {
  console.error(`out dir not found: ${outDir}`);
  console.error("Run `pnpm build` first so the static export exists.");
  process.exit(1);
}

const allHashes = new Set();
for (const htmlFile of walkHtmlFiles(outDir)) {
  const html = fs.readFileSync(htmlFile, "utf8");
  for (const hash of computeInlineScriptHashes(html)) allHashes.add(hash);
}

const hashes = [...allHashes].sort();
if (hashes.length === 0) {
  console.error("No inline script hashes found. Is this a Next.js static export?");
  process.exit(1);
}

fs.mkdirSync(path.dirname(target), { recursive: true });
fs.writeFileSync(
  target,
  `/**
 * Generated file â€” do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * This contains a SHA-256 allow-list of inline \`<script>\` blocks emitted by the
 * Next.js static export (App Router). CloudFront uses these hashes in CSP
 * \`script-src\` to keep a strict policy without \`unsafe-inline\`.
 */

export const NEXT_INLINE_SCRIPT_HASHES = [
${hashes.map((hash) => `  "${hash}",`).join("\n")}
] as const;
`,
  "utf8",
);

process.stdout.write(
  JSON.stringify(
    {
      outDir,
      target,
      hashCount: hashes.length,
    },
    null,
    2,
  ) + "\n",
);
