import crypto from "node:crypto";
import fs from "node:fs";
import path from "node:path";

function readArg(flag) {
  const idx = process.argv.indexOf(flag);
  if (idx === -1) return null;
  const value = process.argv[idx + 1];
  if (!value || value.startsWith("--")) return null;
  return value;
}

function* walkHtmlFiles(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) yield* walkHtmlFiles(fullPath);
    else if (entry.isFile() && fullPath.endsWith(".html")) yield fullPath;
  }
}

function computeInlineScriptHashes(html) {
  const hashes = new Set();
  // Match inline scripts defensively (CodeQL: js/bad-tag-filter).
  // Tolerate malformed closing tags like `</script >` or even `</script\t\n foo>`.
  const scriptRe = /<script\b([^>]*)>([\s\S]*?)<\/script\b[^>]*>/gi;

  let match;
  while ((match = scriptRe.exec(html))) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";

    // External scripts are covered by `'self'` and don't need hashes.
    if (/\bsrc\s*=/i.test(attrs)) continue;

    // Ignore JSON-LD blocks.
    const type = (attrs.match(/\btype\s*=\s*"([^"]+)"/i)?.[1] ?? "").toLowerCase();
    if (type === "application/ld+json") continue;

    // Ignore empty scripts.
    if (!body.trim()) continue;

    const digest = crypto.createHash("sha256").update(body, "utf8").digest("base64");
    hashes.add(`sha256-${digest}`);
  }

  return hashes;
}

const outDir = path.resolve(readArg("--out-dir") ?? "out");
const target = path.resolve(
  readArg("--target") ?? "infrastructure/lib/generated/next-inline-script-hashes.ts",
);
const perPathTarget = path.resolve(
  readArg("--per-path-target") ?? "infrastructure/lib/generated/next-inline-script-hashes.json",
);
const functionTarget = path.resolve(
  readArg("--function-target") ??
    "infrastructure/lib/functions/cloudfront/next-csp-response.js",
);

if (!fs.existsSync(outDir)) {
  console.error(`out dir not found: ${outDir}`);
  console.error("Run `pnpm build` first so the static export exists.");
  process.exit(1);
}

const allHashes = new Set();
const perPathHashes = {};
for (const htmlFile of walkHtmlFiles(outDir)) {
  const html = fs.readFileSync(htmlFile, "utf8");
  const hashes = [...computeInlineScriptHashes(html)].sort();
  for (const hash of hashes) allHashes.add(hash);
  const relativePath = `/${path
    .relative(outDir, htmlFile)
    .split(path.sep)
    .join("/")}`;
  perPathHashes[relativePath] = hashes;
}

const hashes = [...allHashes].sort();
if (hashes.length === 0) {
  console.error("No inline script hashes found. Is this a Next.js static export?");
  process.exit(1);
}

fs.mkdirSync(path.dirname(target), { recursive: true });
fs.writeFileSync(
  target,
  `/**
 * Generated file — do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * This contains a SHA-256 allow-list of inline \`<script>\` blocks emitted by the
 * Next.js static export (App Router). CloudFront uses these hashes in CSP
 * \`script-src\` to keep a strict policy without \`unsafe-inline\`.
 */

export const NEXT_INLINE_SCRIPT_HASHES = [
${hashes.map((hash) => `  "${hash}",`).join("\n")}
] as const;
`,
  "utf8",
);

fs.writeFileSync(perPathTarget, `${JSON.stringify(perPathHashes, null, 2)}\n`, "utf8");

const functionSource = `/* biome-ignore-all lint/style/useTemplate: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/complexity/useOptionalChain: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/correctness/noUnusedVariables: CloudFront handler is invoked by AWS. */
/* biome-ignore-all lint/style/useConst: CloudFront Functions require ES5.1. */
/**
 * Generated file — do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * CloudFront Functions runtime constraints:
 * - ES5.1 only (no const/let, no arrow functions, no template literals)
 * - No module system (no require/import)
 * - No Node.js APIs
 */
var PATH_HASHES = ${JSON.stringify(perPathHashes, null, 2)};

var BASE_DIRECTIVES = [
  "default-src 'self'",
  "img-src 'self' data: blob:",
  "style-src 'self' 'unsafe-inline'",
  "font-src 'self' data:",
  "frame-ancestors 'none'",
  "base-uri 'self'",
  "form-action 'self'",
  "upgrade-insecure-requests"
];

var SCRIPT_PREFIX = "script-src 'self'";

// Include test domains so infra tests can validate connect-src values.
var CONNECT_SRC_BY_HOST = {
  "bjornmelin.io": "https://api.bjornmelin.io",
  "www.bjornmelin.io": "https://api.bjornmelin.io",
  "example.com": "https://api.example.com",
  "www.example.com": "https://api.example.com"
};

function normalizePath(uri) {
  if (!uri) return "/index.html";
  var decoded = decodeURIComponent(uri.split("?")[0].split("#")[0]);
  if (decoded.charAt(decoded.length - 1) === "/") return decoded + "index.html";
  var lastSegment = decoded.split("/").pop() || "";
  if (lastSegment.indexOf(".") === -1) return decoded + "/index.html";
  return decoded;
}

function buildCsp(host, hashes) {
  var normalizedHost = (host || "").toLowerCase().split(":")[0];
  var connectSrc = CONNECT_SRC_BY_HOST[normalizedHost];
  var script = SCRIPT_PREFIX + " " + hashes.map(function (hash) {
    return "'" + hash + "'";
  }).join(" ");
  var connectDirective = connectSrc
    ? "connect-src 'self' " + connectSrc
    : "connect-src 'self'";
  return BASE_DIRECTIVES.concat([script, connectDirective]).join("; ");
}

function handler(event) {
  var request = event.request || {};
  var response = event.response || {};
  var uri = request.uri || "/index.html";
  var normalized = normalizePath(uri);
  var hashes =
    PATH_HASHES[normalized] ||
    PATH_HASHES["/404.html"] ||
    PATH_HASHES["/index.html"] ||
    [];
  var hostHeader =
    request.headers && request.headers.host && request.headers.host.value;
  var csp = buildCsp(hostHeader || "", hashes);
  response.headers = response.headers || {};
  response.headers["content-security-policy"] = { value: csp };
  return response;
}
`;

fs.writeFileSync(functionTarget, `${functionSource}\n`, "utf8");

process.stdout.write(
  JSON.stringify(
    {
      outDir,
      target,
      perPathTarget,
      functionTarget,
      hashCount: hashes.length,
    },
    null,
    2,
  ) + "\n",
);
